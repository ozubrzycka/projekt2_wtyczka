# -*- coding: utf-8 -*-
"""
/***************************************************************************
 wtyczkaoaDialog
                                 A QGIS plugin
 Wtyczka służy do przetwarzania i analizy danych geoprzestrzennych bezpośrednio w QGIS. Oferuje następujące funkcjonalności: Obliczanie różnicy wysokości oraz obliczanie pola powierzchni metodą Gaussa
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Oliwia Zubrzycka, Alicja Wiatr
        email                : 01179242@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from math import atan2, sqrt, pi
from qgis.utils import iface
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsFeature, QgsGeometry, QgsPointXY
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtGui import QIcon

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'wtyczkaoa_dialog_base.ui'))


class wtyczkaoaDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(wtyczkaoaDialog, self).__init__(parent)
        self.setupUi(self)
        self.height_difference.clicked.connect(self.height_difference_function)
        self.count_points.clicked.connect(self.count_elements)
        self.display_coordinates.clicked.connect(self.coordinates_function)
        self.area.clicked.connect(self.area_function)
        self.clear_table.clicked.connect(self.clear_array_function)
        self.close_button.clicked.connect(self.clear_data_function)
        self.azimuth.clicked.connect(self.azimuth_function)
        self.segment_length.clicked.connect(self.segment_length_function)
        self.reset_all.clicked.connect(self.clear_data_function)
        self.save_file.clicked.connect(self.save_file_function)
        self.reverse_azimuth.clicked.connect(self.azimuth_function)
        self.load_file.clicked.connect(self.select_file_function)
        
    def show_error_message(self, error_message):
        error_dialog = QMessageBox()
        error_dialog.setIcon(QMessageBox.Critical)
        error_dialog.setText(error_message)
        error_dialog.setWindowTitle("Error")
        error_dialog.exec_()

    def check_current_layer(self):
        current_layer = self.mMapLayerComboBox_layers.currentLayer()
        if current_layer is None:
            self.show_error_message("No layer selected")
            return False
        return True 

    def segment_length_function(self):
        if not self.check_current_layer():
            return
    
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        num_elements = len(selected_features)
        if num_elements == 2:
            points = [[feature.geometry().asPoint().x(), feature.geometry().asPoint().y()] for feature in selected_features]
            distance = sqrt((points[0][0] - points[1][0])**2 + (points[0][1] - points[1][1])**2)
            self.segment_length_result.setText(f'Distance between points (point id:1- id:2) is: {distance:.3f} [m]')
            return distance
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def extract_coordinates(self, selected_features):
        coords = []
        for feature in selected_features:
            wsp = feature.geometry().asPoint()
            coords.append([wsp.x(), wsp.y()])
        return coords
    
    def convert_azimuth_units(self, azimuth):
        reverse_azimuth = azimuth + pi if azimuth < 0 else azimuth - pi
        return azimuth, reverse_azimuth
    
    def calculate_azimuth(self):
        if not self.check_current_layer():
            return None, None
    
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        num_elements = len(selected_features)
        if num_elements == 2:
            coords = self.extract_coordinates(selected_features)
            azimuth = atan2((coords[1][1] - coords[0][1]), (coords[1][0] - coords[0][0]))
            
            # Tutaj przekształcamy azymut na stopnie dziesiętne lub grady
            if 'decimal degrees' == self.unit_azimuth.currentText():
                azimuth *= 180 / pi
                if azimuth < 0:
                    azimuth += 360
            elif 'grads' == self.unit_azimuth.currentText():
                azimuth *= 200 / pi
                if azimuth < 0:
                    azimuth += 400
            
            # Obliczamy odwrotny azymut
            reverse_azimuth = azimuth + 180 if azimuth >= 180 else azimuth - 180
            
            # Formatujemy wyniki
            azimuth_text = f'Azimuth is (point id:1- id:2): {azimuth:.7f}[decimal degrees]' if 'decimal degrees' == self.unit_azimuth.currentText() else f'Azimuth is (point id:1- id:2): {azimuth:.4f}[grads]'
            reverse_azimuth_text = f'Reverse azimuth is (point id:2- id:1): {reverse_azimuth:.7f}[decimal degrees]' if 'decimal degrees' == self.unit_azimuth.currentText() else f'Reverse azimuth is (point id:2- id:1): {reverse_azimuth:.4f}[grads]'
            
            # Aktualizujemy etykiety w interfejsie użytkownika
            self.azimuth_result.setText(azimuth_text)
            self.reverse_azimuth_result.setText(reverse_azimuth_text)
            
            return azimuth, reverse_azimuth
        else:
            self.show_error_message("Error: Incorrect number of points selected")
            return None, None


    def azimuth_function(self):
        if not self.check_current_layer():
            return
        
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        num_elements = len(selected_features)
        print(f"Number of selected elements: {num_elements}")  # Debugging
        
        if num_elements == 2:
            K = []
            for element in selected_features:
                wsp = element.geometry().asPoint()
                X = wsp.x()
                Y = wsp.y()
                K.append([X, Y])
                print(f"Point: X={X}, Y={Y}")  # Debugging
            
            Az = atan2((K[1][1] - K[0][1]), (K[1][0] - K[0][0]))
            print(f"Initial Azimuth (radians): {Az}")  # Debugging
            
            if 'decimal degrees' == self.unit_azimuth.currentText():
                Az = Az * 180 / pi
                if Az < 0:
                    Az += 360
                elif Az > 360:
                    Az -= 360
                self.azimuth_result.setText(f'Azimuth is (point id:1- id:2): {Az:.7f}[decimal degrees]')
                print(f"Azimuth (decimal degrees): {Az}")  # Debugging
            
                Az_odw = Az + 180
                if Az_odw >= 360:
                    Az_odw -= 360
                self.reverse_azimuth_result.setText(f'Reverse azimuth is (point id:2- id:1): {Az_odw:.7f}[decimal degrees]')
                print(f"Reverse Azimuth (decimal degrees): {Az_odw}")  # Debugging
            
            elif 'grads' == self.unit_azimuth.currentText():
                Az = Az * 200 / pi
                if Az < 0:
                    Az += 400
                elif Az >= 400:
                    Az -= 400
                self.azimuth_result.setText(f'Azimuth is (point id:1- id:2): {Az:.4f}[grads]')
                print(f"Azimuth (grads): {Az}")  # Debugging
            
                Az_odw = Az + 200
                if Az_odw >= 400:
                    Az_odw -= 400
                self.reverse_azimuth_result.setText(f'Reverse azimuth is (point id:2- id:1): {Az_odw:.4f}[grads]')
                print(f"Reverse Azimuth (grads): {Az_odw}")  # Debugging
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def count_elements(self):
        if not self.check_current_layer():
            return
        num_elements = len(self.mMapLayerComboBox_layers.currentLayer().selectedFeatures())
        self.show_point_count.setText(str(num_elements))
        return num_elements

    def coordinates_function(self):
        if not self.check_current_layer():
            return
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        coordinates = [[feature.geometry().asPoint().x(), feature.geometry().asPoint().y()] for feature in selected_features]
        self.coordinates_array.setRowCount(len(coordinates))
        for i, (x, y) in enumerate(coordinates):
            self.coordinates_array.setItem(i, 0, QtWidgets.QTableWidgetItem(str(x)))
            self.coordinates_array.setItem(i, 1, QtWidgets.QTableWidgetItem(str(y)))
        return coordinates

    def height_difference_function(self):
        if not self.check_current_layer():
            return
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        if len(selected_features) == 2:
            heights = [feature.geometry().z() for feature in selected_features]
            height_diff = abs(heights[1] - heights[0])
            self.height_difference_result.setText(f'Height difference: {height_diff:.3f} [m]')
            return height_diff
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def area_function(self):
        if not self.check_current_layer():
            return
        selected_features = self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()
        if len(selected_features) >= 3:
            points = [[feature.geometry().asPoint().x(), feature.geometry().asPoint().y()] for feature in selected_features]
            area = 0
            for i in range(-1, len(points) - 1):
                area += points[i][0] * points[i + 1][1] - points[i + 1][0] * points[i][1]
            area = abs(area) / 2
            self.area_result.setText(f'Area: {area:.3f} [m²]')
            return area
        else:
            self.show_error_message("Error: At least 3 points required")

    def clear_array_function(self):
        self.azimuth_result.clear()
        self.reverse_azimuth_result.clear()
        self.height_difference_result.clear()
        self.area_result.clear()
        self.show_point_count.clear()
        self.coordinates_array.clearContents()

    def clear_data_function(self):
        self.clear_array_function()

    def save_file_function(self):
        filepath, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', '', 'Text Files (*.txt)')
        if filepath:
            try:
                with open(filepath, 'w') as file:
                    file.write(f'Azimuth: {self.azimuth_result.text()}\n')
                    file.write(f'Reverse Azimuth: {self.reverse_azimuth_result.text()}\n')
                    file.write(f'Height Difference: {self.height_difference_result.text()}\n')
                    file.write(f'Area: {self.area_result.text()}\n')
                    file.write(f'Point Count: {self.show_point_count.text()}\n')
                    for row in range(self.coordinates_array.rowCount()):
                        x_item = self.coordinates_array.item(row, 0)
                        y_item = self.coordinates_array.item(row, 1)
                        if x_item and y_item:
                            file.write(f'Point {row + 1}: X={x_item.text()}, Y={y_item.text()}\n')
            except Exception as e:
                self.show_error_message(f"Error saving file: {e}")

    def select_file_function(self):
        filepath, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Open File', '', 'Text Files (*.txt)')
        if filepath:
            try:
                with open(filepath, 'r') as file:
                    data = file.readlines()
                    self.clear_array_function()
                    self.azimuth_result.setText(data[0].strip().split(': ')[1])
                    self.reverse_azimuth_result.setText(data[1].strip().split(': ')[1])
                    self.height_difference_result.setText(data[2].strip().split(': ')[1])
                    self.area_result.setText(data[3].strip().split(': ')[1])
                    self.show_point_count.setText(data[4].strip().split(': ')[1])
                    for i, line in enumerate(data[5:]):
                        x, y = line.strip().split(': ')[1].split(', ')
                        self.coordinates_array.setRowCount(i + 1)
                        self.coordinates_array.setItem(i, 0, QtWidgets.QTableWidgetItem(x.split('=')[1]))
                        self.coordinates_array.setItem(i, 1, QtWidgets.QTableWidgetItem(y.split('=')[1]))
            except Exception as e:
                self.show_error_message(f"Error loading file: {e}")

