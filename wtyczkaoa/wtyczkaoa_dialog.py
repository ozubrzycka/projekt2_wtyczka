# -*- coding: utf-8 -*-
"""
/***************************************************************************
 wtyczkaoaDialog
                                 A QGIS plugin
 Wtyczka służy do przetwarzania i analizy danych geoprzestrzennych bezpośrednio w QGIS. Oferuje następujące funkcjonalności: Obliczanie różnicy wysokości oraz obliczanie pola powierzchni metodą Gaussa
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Oliwia Zubrzycka, Alicja Wiatr
        email                : 01179242@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from math import atan2, sqrt, pi
from qgis.utils import iface
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsField, QgsFeature, QgsGeometry, QgsVectorLayer, QgsPointXY, QgsProject, QgsCoordinateReferenceSystem, QgsFields
from PyQt5.QtCore import QVariant
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtGui import QIcon

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'wtyczkaoa_dialog_base.ui'))


class wtyczkaoaDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(wtyczkaoaDialog, self).__init__(parent)
        self.setupUi(self)
        self.height_difference.clicked.connect(self.height_difference_function)
        self.count_points.clicked.connect(self.count_elements)
        self.display_coordinates.clicked.connect(self.coordinates_function)
        self.area.clicked.connect(self.area_function)
        self.clear_table.clicked.connect(self.clear_array_function)
        self.close_button.clicked.connect(self.clear_data_function)
        self.azimuth.clicked.connect(self.azimuth_function)
        self.segment_length.clicked.connect(self.segment_length_function)
        self.reset_all.clicked.connect(self.clear_data_function)
        self.save_file.clicked.connect(self.save_file_function)
        self.reverse_azimuth.clicked.connect(self.azimuth_function)
        self.load_file.clicked.connect(self.select_file_function)

    def show_error_message(self, error_message):
        error_dialog = QMessageBox()
        error_dialog.setIcon(QMessageBox.Critical)
        error_dialog.setText(error_message)
        error_dialog.setWindowTitle("Error")
        error_dialog.exec_()

    def check_current_layer(self):
        current_layer = self.mMapLayerComboBox_layers.currentLayer()
        if current_layer is None:
            self.show_error_message("No layer selected")
            return False
        return True 

    def selected_features(self):
        return self.mMapLayerComboBox_layers.currentLayer().selectedFeatures()

    def segment_length_function(self):
        if not self.check_current_layer():
            return
    
        num_elements = len(self.selected_features())
        if num_elements == 2:
            selected_features = self.selected_features()
            points = [[feature.geometry().asPoint().x(), feature.geometry().asPoint().y()] for feature in selected_features]
            distance = sqrt((points[0][0] - points[1][0])**2 + (points[0][1] - points[1][1])**2)
            self.segment_length_result.setText(f'Distance between points (point id:1- id:2) is: {distance:.3f} [m]')
            return distance
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def calculate_azimuth(self):
        if not self.check_current_layer():
            return
        num_elements = len(self.selected_features())
        if num_elements == 2:
            coords = self.extract_coordinates(self.selected_features())
            azimuth = atan2((coords[1][1] - coords[0][1]), (coords[1][0] - coords[0][0]))
            azimuth, reverse_azimuth = self.convert_azimuth_units(azimuth)
            self.azimuth_result.setText(f'Azimuth is(point id:1- id:2): {azimuth}')
            self.reverse_azimuth_result.setText(f'Reverse azimuth is (point id:2- id:1): {reverse_azimuth}')
            return azimuth, reverse_azimuth
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def azimuth_function(self):
        if not self.check_current_layer():
            return
    
        num_elements = len(self.selected_features())
        print(f"Number of selected elements: {num_elements}")  # Debugging
    
        if num_elements == 2:
            selected_features = self.selected_features()
            K = []
            for element in selected_features:
                wsp = element.geometry().asPoint()
                X = wsp.x()
                Y = wsp.y()
                K.append([X, Y])
                print(f"Point: X={X}, Y={Y}")  # Debugging
        
            Az = atan2((K[1][1] - K[0][1]), (K[1][0] - K[0][0]))
            print(f"Initial Azimuth (radians): {Az}")  # Debugging
        
            if 'decimal_degrees' == self.unit_azimuth.currentText():
                Az = Az * 180 / pi
                if Az < 0:
                    Az += 360
                elif Az > 360:
                    Az -= 360
                self.azimuth_result.setText(f'Azimuth is (point id:1- id:2): {Az:.7f}[decimal_degrees]')
                print(f"Azimuth (decimal_degrees): {Az}")  # Debugging
            
                Az_odw = Az + 180
                if Az_odw < 0:
                    Az_odw += 360
                elif Az_odw > 360:
                    Az_odw -= 360
                self.reverse_azimuth_result.setText(f'Reverse azimuth is (point id:2- id:1): {Az_odw:.7f}[decimal_degrees]')
                print(f"Reverse Azimuth (decimal_degrees): {Az_odw}")  # Debugging
            
            elif 'grads' == self.unit_azimuth.currentText():
                Az = Az * 200 / pi
                if Az < 0:
                    Az += 400
                elif Az > 400:
                    Az -= 400
                self.azimuth_result.setText(f'Azimuth is (point id:1- id:2): {Az:.4f}[grads]')
                print(f"Azimuth (grads): {Az}")  # Debugging
            
                Az_odw = Az + 200
                if Az_odw < 0:
                    Az_odw += 400
                elif Az_odw > 400:
                    Az_odw -= 400
                self.reverse_azimuth_result.setText(f'Reverse azimuth is (point id:2- id:1): {Az_odw:.4f}[grads]')
                print(f"Reverse Azimuth (grads): {Az_odw}")  # Debugging
        else:
            self.show_error_message("Error: Incorrect number of points selected")

    def count_elements(self):
        if not self.check_current_layer():
            return
        num_elements = len(self.selected_features())
        self.show_point_count.setText(str(num_elements))

    def coordinates_function(self):
        if not self.check_current_layer():
            return
        selected_features = self.selected_features()
        coords = ""
        point_id = 1
        for feature in selected_features:
            wsp = feature.geometry().asPoint()
            X = wsp.x()
            Y = wsp.y()
            coords += f'Coordinates of point {point_id}: X = {X:.3f}, Y = {Y:.3f}\n'
            point_id += 1
        self.coordinates.setText(coords)

    def height_difference_function(self):
        if not self.check_current_layer():
            return
        num_elements = len(self.selected_features())
        heights = []
        if num_elements == 2:
            selected_layer = iface.activeLayer()
            selected_features = selected_layer.selectedFeatures()
            for feature in selected_features:
                height = float(feature[20])
                heights.append(height)
            height_difference = heights[1] - heights[0]
            self.height_difference_result.setText(f'Height difference {height_difference:.3f}[m]')
            return height_difference
        elif num_elements < 2:
            self.height_difference_result.setText("Error")
            self.show_error_message("Too few points selected")
        elif num_elements > 2:
            self.height_difference_result.setText("Error")
            self.show_error_message("Too many points selected")

    def get_angle(self, point, centroid):
        dx = point[0] - centroid[0]
        dy = point[1] - centroid[1]
        angle = atan2(dy, dx)
        return angle

    def sort_points(self, points):
        centroid = [sum(p[0] for p in points) / len(points), sum(p[1] for p in points) / len(points)]
        sorted_points = sorted(points, key=lambda p: self.get_angle(p, centroid))
        return sorted_points

    def area_function(self):
        if not self.check_current_layer():
            return
        num_elements = len(self.selected_features())
        if num_elements >= 3:
            selected_features = self.selected_features()
            points = []
            for feature in selected_features:
                point = feature.geometry().asPoint()
                points.append([point.x(), point.y()])
            points = self.sort_points(points)
            area_sum = 0
            for i in range(num_elements):
                x1, y1 = points[i]
                x2, y2 = points[(i + 1) % num_elements]
                area_sum += (x1 * y2) - (y1 * x2)
            area = abs(area_sum) / 2
            self.area_result.setText(f'The area is {area:.3f}[m^2]')
            return area
        else:
            self.show_error_message("Error: At least 3 points must be selected")

    def save_file_function(self):
        if not self.check_current_layer():
            return
        output_path = self.save_file_path.text()
        if not output_path:
            self.show_error_message("Please enter a valid file path")
            return

        layer = self.mMapLayerComboBox_layers.currentLayer()
        fields = QgsFields()
        fields.append(QgsField("ID", QVariant.Int))
        fields.append(QgsField("X", QVariant.Double))
        fields.append(QgsField("Y", QVariant.Double))

        crs = QgsCoordinateReferenceSystem(4326)  # WGS 84
        writer = QgsVectorFileWriter(output_path, 'UTF-8', fields, QgsWkbTypes.Point, crs, 'ESRI Shapefile')

        for feature in layer.getFeatures():
            geometry = feature.geometry()
            point = geometry.asPoint()
            id_value = feature.id()
            new_feature = QgsFeature()
            new_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(point.x(), point.y())))
            new_feature.setAttributes([id_value, point.x(), point.y()])
            writer.addFeature(new_feature)

        del writer

        if os.path.exists(output_path):
            self.show_error_message(f"File saved successfully at {output_path}")
        else:
            self.show_error_message("Error saving file")

    def clear_array_function(self):
        self.show_point_count.clear()
        self.coordinates.clear()
        self.height_difference_result.clear()
        self.azimuth_result.clear()
        self.reverse_azimuth_result.clear()
        self.segment_length_result.clear()
        self.area_result.clear()

    def clear_data_function(self):
        self.mMapLayerComboBox_layers.setCurrentIndex(-1)
        self.save_file_path.clear()
        self.clear_array_function()

    def extract_coordinates(self, features):
        return [[feature.geometry().asPoint().x(), feature.geometry().asPoint().y()] for feature in features]

    def convert_azimuth_units(self, azimuth):
        azimuth_deg = azimuth * 180 / pi
        if azimuth_deg < 0:
            azimuth_deg += 360
        elif azimuth_deg > 360:
            azimuth_deg -= 360
        reverse_azimuth_deg = azimuth_deg + 180
        if reverse_azimuth_deg < 0:
            reverse_azimuth_deg += 360
        elif reverse_azimuth_deg > 360:
            reverse_azimuth_deg -= 360
        return azimuth_deg, reverse_azimuth_deg
